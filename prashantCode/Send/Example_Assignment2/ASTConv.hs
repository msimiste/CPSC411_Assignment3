module ASTConv where

-- Haskell module generated by the BNF converter

import Parser
import qualified AST as A 

transIdent :: Ident -> String 
transIdent x = case x of
  Ident string -> string

transProg :: Prog -> A.Stmt 
transProg x = case x of
  ProgStmt stmt -> transStmt stmt 

transStmt :: Stmt -> A.Stmt
transStmt x = case x of

  Stmt_1 expr stmt1 stmt2 ->
      A.If (transExpr expr) (transStmt stmt1) (transStmt stmt2)

  Stmt_2 expr stmt -> 
      A.While (transExpr expr) (transStmt stmt)

  Stmt_3 expr -> 
      A.Input (transExpr expr)

  Stmt_4 ident expr -> 
      A.Assign (transIdent ident) (transExpr expr)

  Stmt_5 expr -> 
      A.Write (transExpr expr)

  Stmt_6 stmts -> 
      A.Block (map transStmt stmts)


transExpr :: Expr -> A.Exp 
transExpr x = case x of
  Expr_1 expr addop term -> 
      case transAddop addop of
          "+" -> A.Add (transExpr expr) (transTerm term)
          "-" -> A.Add (transExpr expr) (A.Neg (transTerm term)) 
  ExprTerm term -> transTerm term

transAddop :: Addop -> String 
transAddop x = case x of
  Addop_1 -> "+"
  Addop_2 -> "-"

transTerm :: Term -> A.Exp
transTerm x = case x of
  Term_1 term mulop factor -> 
     case transMulop mulop of
        "*" -> A.Mul (transTerm term) (transFactor factor)
        "/" -> A.Div (transTerm term) (transFactor factor)

  TermFactor factor -> (transFactor factor)

transMulop :: Mulop -> String
transMulop x = case x of
  Mulop_1 -> "*"
  Mulop_2 -> "/"

transFactor :: Factor -> A.Exp 
transFactor x = case x of
  Factor_1 expr -> (transExpr expr)
  FactorIdent ident -> A.Id (transIdent ident)
  FactorInteger integer -> A.Num integer
  Factor_4 integer -> A.Neg (A.Num integer)

