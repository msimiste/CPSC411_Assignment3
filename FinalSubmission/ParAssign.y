-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParAssign where
import AbsAssign
import LexAssign
import ErrM

}

%name pProg Prog
%name pBlock Block
%name pDeclarations Declarations
%name pDeclaration Declaration
%name pVar_declaration Var_declaration
%name pType Type
%name pArray_dimensions Array_dimensions
%name pFun_declaration Fun_declaration
%name pFun_block Fun_block
%name pParam_list Param_list
%name pParameters Parameters
%name pMore_parameters More_parameters
%name pBasic_declaration Basic_declaration
%name pBasic_array_dimensions Basic_array_dimensions
%name pProgram_body Program_body
%name pFun_body Fun_body
%name pProg_stmts Prog_stmts
%name pProg_stmt Prog_stmt
%name pIdentifier Identifier
%name pExpr Expr
%name pBint_term Bint_term
%name pBint_factor Bint_factor
%name pCompare_op Compare_op
%name pInt_expr Int_expr
%name pAddop Addop
%name pInt_term Int_term
%name pMulop Mulop
%name pInt_factor Int_factor
%name pModifier_list Modifier_list
%name pArguments Arguments
%name pMore_arguments More_arguments
%name pBVAL BVAL
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '&&' { PT _ (TS _ 1) }
  '(' { PT _ (TS _ 2) }
  ')' { PT _ (TS _ 3) }
  '*' { PT _ (TS _ 4) }
  '+' { PT _ (TS _ 5) }
  ',' { PT _ (TS _ 6) }
  '-' { PT _ (TS _ 7) }
  '/' { PT _ (TS _ 8) }
  ':' { PT _ (TS _ 9) }
  ':=' { PT _ (TS _ 10) }
  ';' { PT _ (TS _ 11) }
  '<' { PT _ (TS _ 12) }
  '=' { PT _ (TS _ 13) }
  '=<' { PT _ (TS _ 14) }
  '>' { PT _ (TS _ 15) }
  '>=' { PT _ (TS _ 16) }
  '[' { PT _ (TS _ 17) }
  ']' { PT _ (TS _ 18) }
  'begin' { PT _ (TS _ 19) }
  'bool' { PT _ (TS _ 20) }
  'ceil' { PT _ (TS _ 21) }
  'do' { PT _ (TS _ 22) }
  'else' { PT _ (TS _ 23) }
  'end' { PT _ (TS _ 24) }
  'false' { PT _ (TS _ 25) }
  'float' { PT _ (TS _ 26) }
  'floor' { PT _ (TS _ 27) }
  'fun' { PT _ (TS _ 28) }
  'if' { PT _ (TS _ 29) }
  'int' { PT _ (TS _ 30) }
  'not' { PT _ (TS _ 31) }
  'print' { PT _ (TS _ 32) }
  'read' { PT _ (TS _ 33) }
  'real' { PT _ (TS _ 34) }
  'return' { PT _ (TS _ 35) }
  'size' { PT _ (TS _ 36) }
  'then' { PT _ (TS _ 37) }
  'true' { PT _ (TS _ 38) }
  'var' { PT _ (TS _ 39) }
  'while' { PT _ (TS _ 40) }
  '{' { PT _ (TS _ 41) }
  '||' { PT _ (TS _ 42) }
  '}' { PT _ (TS _ 43) }

L_ident  { PT _ (TV $$) }
L_IVAL { PT _ (T_IVAL $$) }
L_RVAL { PT _ (T_RVAL $$) }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
IVAL    :: { IVAL} : L_IVAL { IVAL ($1)}
RVAL    :: { RVAL} : L_RVAL { RVAL ($1)}

Prog :: { Prog }
Prog : Block { AbsAssign.ProgBlock $1 }
Block :: { Block }
Block : Declarations Program_body { AbsAssign.Block1 $1 $2 }
Declarations :: { Declarations }
Declarations : Declaration ';' Declarations { AbsAssign.Declarations1 $1 $3 }
             | {- empty -} { AbsAssign.Declarations2 }
Declaration :: { Declaration }
Declaration : Var_declaration { AbsAssign.DeclarationVar_declaration $1 }
            | Fun_declaration { AbsAssign.DeclarationFun_declaration $1 }
Var_declaration :: { Var_declaration }
Var_declaration : 'var' Ident Array_dimensions ':' Type { AbsAssign.Var_declaration1 $2 $3 $5 }
Type :: { Type }
Type : 'int' { AbsAssign.Type_int }
     | 'real' { AbsAssign.Type_real }
     | 'bool' { AbsAssign.Type_bool }
Array_dimensions :: { Array_dimensions }
Array_dimensions : '[' Expr ']' Array_dimensions { AbsAssign.Array_dimensions1 $2 $4 }
                 | {- empty -} { AbsAssign.Array_dimensions2 }
Fun_declaration :: { Fun_declaration }
Fun_declaration : 'fun' Ident Param_list ':' Type '{' Fun_block '}' { AbsAssign.Fun_declaration1 $2 $3 $5 $7 }
Fun_block :: { Fun_block }
Fun_block : Declarations Fun_body { AbsAssign.Fun_block1 $1 $2 }
Param_list :: { Param_list }
Param_list : '(' Parameters ')' { AbsAssign.Param_list1 $2 }
Parameters :: { Parameters }
Parameters : Basic_declaration More_parameters { AbsAssign.Parameters1 $1 $2 }
           | {- empty -} { AbsAssign.Parameters2 }
More_parameters :: { More_parameters }
More_parameters : ',' Basic_declaration More_parameters { AbsAssign.More_parameters1 $2 $3 }
                | {- empty -} { AbsAssign.More_parameters2 }
Basic_declaration :: { Basic_declaration }
Basic_declaration : Ident Basic_array_dimensions ':' Type { AbsAssign.Basic_declaration1 $1 $2 $4 }
Basic_array_dimensions :: { Basic_array_dimensions }
Basic_array_dimensions : '[' ']' Basic_array_dimensions { AbsAssign.Basic_array_dimensions1 $3 }
                       | {- empty -} { AbsAssign.Basic_array_dimensions2 }
Program_body :: { Program_body }
Program_body : 'begin' Prog_stmts 'end' { AbsAssign.Program_body1 $2 }
Fun_body :: { Fun_body }
Fun_body : 'begin' Prog_stmts 'return' Expr ';' 'end' { AbsAssign.Fun_body1 $2 $4 }
Prog_stmts :: { Prog_stmts }
Prog_stmts : Prog_stmt ';' Prog_stmts { AbsAssign.Prog_stmts1 $1 $3 }
           | {- empty -} { AbsAssign.Prog_stmts2 }
Prog_stmt :: { Prog_stmt }
Prog_stmt : 'if' Expr 'then' Prog_stmt 'else' Prog_stmt { AbsAssign.Prog_stmt1 $2 $4 $6 }
          | 'while' Expr 'do' Prog_stmt { AbsAssign.Prog_stmt2 $2 $4 }
          | 'read' Identifier { AbsAssign.Prog_stmt3 $2 }
          | Identifier ':=' Expr { AbsAssign.Prog_stmt4 $1 $3 }
          | 'print' Expr { AbsAssign.Prog_stmt5 $2 }
          | '{' Block '}' { AbsAssign.Prog_stmt6 $2 }
Identifier :: { Identifier }
Identifier : Ident Array_dimensions { AbsAssign.Identifier1 $1 $2 }
Expr :: { Expr }
Expr : Expr '||' Bint_term { AbsAssign.Expr1 $1 $3 }
     | Bint_term { AbsAssign.ExprBint_term $1 }
Bint_term :: { Bint_term }
Bint_term : Bint_term '&&' Bint_factor { AbsAssign.Bint_term1 $1 $3 }
          | Bint_factor { AbsAssign.Bint_termBint_factor $1 }
Bint_factor :: { Bint_factor }
Bint_factor : 'not' Bint_factor { AbsAssign.Bint_factor1 $2 }
            | Int_expr Compare_op Int_expr { AbsAssign.Bint_factor2 $1 $2 $3 }
            | Int_expr { AbsAssign.Bint_factorInt_expr $1 }
Compare_op :: { Compare_op }
Compare_op : '=' { AbsAssign.Compare_op1 }
           | '<' { AbsAssign.Compare_op2 }
           | '>' { AbsAssign.Compare_op3 }
           | '=<' { AbsAssign.Compare_op4 }
           | '>=' { AbsAssign.Compare_op5 }
Int_expr :: { Int_expr }
Int_expr : Int_expr Addop Int_term { AbsAssign.Int_expr1 $1 $2 $3 }
         | Int_term { AbsAssign.Int_exprInt_term $1 }
Addop :: { Addop }
Addop : '+' { AbsAssign.Addop1 } | '-' { AbsAssign.Addop2 }
Int_term :: { Int_term }
Int_term : Int_term Mulop Int_factor { AbsAssign.Int_term1 $1 $2 $3 }
         | Int_factor { AbsAssign.Int_termInt_factor $1 }
Mulop :: { Mulop }
Mulop : '*' { AbsAssign.Mulop1 } | '/' { AbsAssign.Mulop2 }
Int_factor :: { Int_factor }
Int_factor : '(' Expr ')' { AbsAssign.Int_factor1 $2 }
           | 'size' '(' Ident Basic_array_dimensions ')' { AbsAssign.Int_factor2 $3 $4 }
           | 'float' '(' Expr ')' { AbsAssign.Int_factor3 $3 }
           | 'floor' '(' Expr ')' { AbsAssign.Int_factor4 $3 }
           | 'ceil' '(' Expr ')' { AbsAssign.Int_factor5 $3 }
           | Ident Modifier_list { AbsAssign.Int_factor6 $1 $2 }
           | IVAL { AbsAssign.Int_factorIVAL $1 }
           | RVAL { AbsAssign.Int_factorRVAL $1 }
           | BVAL { AbsAssign.Int_factorBVAL $1 }
           | '-' Int_factor { AbsAssign.Int_factor7 $2 }
Modifier_list :: { Modifier_list }
Modifier_list : '(' Arguments ')' { AbsAssign.Modifier_list1 $2 }
              | Array_dimensions { AbsAssign.Modifier_listArray_dimensions $1 }
Arguments :: { Arguments }
Arguments : Expr More_arguments { AbsAssign.Arguments1 $1 $2 }
          | {- empty -} { AbsAssign.Arguments2 }
More_arguments :: { More_arguments }
More_arguments : ',' Expr More_arguments { AbsAssign.More_arguments1 $2 $3 }
               | {- empty -} { AbsAssign.More_arguments2 }
BVAL :: { BVAL }
BVAL : 'true' { AbsAssign.BVAL_true }
     | 'false' { AbsAssign.BVAL_false }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

